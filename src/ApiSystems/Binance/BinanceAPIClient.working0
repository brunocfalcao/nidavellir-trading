<?php

namespace Nidavellir\Trading\ApiSystems\Binance;

use Binance\Util\Url;
use GuzzleHttp\Exception\ClientException;
use Nidavellir\Trading\Models\ApiRequestLog;
use Nidavellir\Trading\Exceptions\TryCatchException;
use GuzzleHttp\Exception\ClientException as GuzzleClientException;
use GuzzleHttp\Exception\ServerException as GuzzleServerException;

class BinanceAPIClient
{
    private $baseURL;
    private $key;
    private $secret;
    private $privateKey;
    private $logger;
    private $timeout;
    private $showWeightUsage;
    private $showHeader;
    private $httpRequest = null;

    public function __construct($args = [])
    {
        $this->baseURL         = $args['baseURL'] ?? null;
        $this->key             = $args['key'] ?? null;
        $this->secret          = $args['secret'] ?? null;
        $this->logger          = $args['logger'] ?? new \Psr\Log\NullLogger();
        $this->timeout         = $args['timeout'] ?? 0;
        $this->showWeightUsage = $args['showWeightUsage'] ?? false;
        $this->showHeader      = $args['showHeader'] ?? false;
        $this->privateKey      = $args['privateKey'] ?? null;
        $this->buildClient($args['httpClient'] ?? null);
    }

    protected function publicRequest($method, $path, array $params = [])
    {
        return $this->processRequest($method, $path, $params);
    }

    protected function signRequest($method, $path, array $params = [])
    {
        $params['timestamp'] = round(microtime(true) * 1000);
        $query = Url::buildQuery($params);

        if ($this->privateKey) {
            openssl_sign($query, $binary_signature, $this->privateKey, OPENSSL_ALGO_SHA256);
            $params['signature'] = base64_encode($binary_signature);
        } else {
            $params['signature'] = hash_hmac('sha256', $query, $this->secret);
        }
        return $this->processRequest($method, $path, $params);
    }

    protected function processRequest($method, $path, $params = [])
    {
        $logData = [
        'path'              => $path,
        'payload'           => $params,
        'http_method'       => $method,
        'http_headers_sent' => [
            'Content-Type' => 'application/json',
            'X-MBX-APIKEY' => $this->key,
        ],
        'hostname'          => gethostname(), // Capture the server's hostname
        ];

        try {
            // Send the request
            $response = $this->httpRequest->request($method, $this->buildQuery($path, $params));

            // Capture response details
            $logData['http_response_code'] = $response->getStatusCode();
            $logData['response'] = json_decode($response->getBody(), true);
            $logData['http_headers_returned'] = $response->getHeaders();

            // Log the request and response
            $this->logApiRequest($logData);
        } catch (GuzzleClientException $e) {
            $responseBody = $e->getResponse()->getBody()->getContents();

            // Capture exception details in log data
            $logData['http_response_code'] = $e->getCode();
            $logData['response'] = $e->getMessage();
            $logData['http_headers_returned'] = $e instanceof \GuzzleHttp\Exception\RequestException && $e->getResponse()
            ? $e->getResponse()->getHeaders()
            : null;

            // Log the error response, regardless of whether we skip the exception
            $this->logApiRequest($logData);

            // Handle HTTP exceptions and skip if necessary
            if ($this->shouldSkipException($e->getCode(), $responseBody)) {
                // Skip the exception and treat it as a success, return the parsed response
                return json_decode($responseBody, true);
            }

            // Throw the exception for other cases
            throw new TryCatchException(throwable: $e);
        }

        // Parse and return the response body
        $body = json_decode($response->getBody(), true);

        if ($this->showWeightUsage) {
            $weights = [];
            foreach ($response->getHeaders() as $name => $value) {
                $name = strtolower($name);
                if (strpos($name, 'x-mbx-used-weight') === 0 ||
                strpos($name, 'x-mbx-order-count') === 0 ||
                strpos($name, 'x-sapi-used') === 0) {
                    $weights[$name] = $value;
                }
            }
            return [
            'data'         => $body,
            'weight_usage' => $weights,
            ];
        }

        if ($this->showHeader) {
            return [
            'data'   => $body,
            'header' => $response->getHeaders(),
            ];
        }

        return $body;
    }

    protected function shouldSkipException($httpCode, $responseBody)
    {
        $skipConfig = config('nidavellir.system.api.params.binance.http_errors_to_skip');

        if (isset($skipConfig[$httpCode])) {
            $errorCodesToSkip = $skipConfig[$httpCode];
            $responseArray = json_decode($responseBody, true);

            // Check if any error code in the response matches the list of codes to skip
            if (isset($responseArray['code']) && in_array($responseArray['code'], $errorCodesToSkip)) {
                return true;
            }
        }

        return false;
    }

    protected function buildQuery($path, $params = []): string
    {
        if (count($params) == 0) {
            return $path;
        }
        return $path . '?' . Url::buildQuery($params);
    }

    protected function buildClient($httpRequest)
    {
        $this->httpRequest = $httpRequest ??
        new \GuzzleHttp\Client([
            'base_uri' => $this->baseURL,
            'headers' => [
                'Content-Type' => 'application/json',
                'X-MBX-APIKEY' => $this->key,
                'User-Agent'   => 'binance-connect-php',
            ],
            'timeout' => $this->timeout,
        ]);
    }

    /**
     * Log API requests to the database using the ApiRequestLog model.
     *
     * @param array $logData
     * @return void
     */
    protected function logApiRequest(array $logData): void
    {
        ApiRequestLog::create([
            'path'                  => $logData['path'],
            'payload'               => $logData['payload'],
            'http_method'           => $logData['http_method'],
            'http_headers_sent'     => $logData['http_headers_sent'],
            'http_response_code'    => $logData['http_response_code'],
            'response'              => $logData['response'],
            'http_headers_returned' => $logData['http_headers_returned'],
            'hostname'              => $logData['hostname'],
        ]);
    }
}
